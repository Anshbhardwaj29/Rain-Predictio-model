# -*- coding: utf-8 -*-
"""weather.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19uiqs9moWCADNizhSGEP85KpCgE_fl0L
"""

# @title Load all Libraries

import numpy as np
import pickle
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
import pandas as pd
from sklearn.preprocessing import LabelEncoder

# @title Import Dataset
df = pd.read_csv('weatherAUS.csv')
df.tail(10)

shape = df.shape
row = shape[0]
col = shape[1]

# Check Missing values for each column
missing_values = df.isnull().sum()
print(missing_values)




# Get the count of each unique RainTomorrow name
location_counts = df['RainTomorrow'].value_counts()
print(location_counts)




#Data filling
df["Date"]=pd.to_datetime(df["Date"])
df["Day"]=df["Date"].dt.day
df["Month"]=df["Date"].dt.month
df["Year"]=df["Date"].dt.year
df.drop("Date",axis=1,inplace=True)

#Fill the missing values NAN with 0
# Fill with the mean for temperature-related columns
df['MinTemp'] = df['MinTemp'].fillna(df['MinTemp'].mean())
df['MaxTemp'] = df['MaxTemp'].fillna(df['MaxTemp'].mean())
df['Temp9am'] = df['Temp9am'].fillna(df['Temp9am'].mean())
df['Temp3pm'] = df['Temp3pm'].fillna(df['Temp3pm'].mean())

# Fill with the median for rainfall-related columns
df['Rainfall'] = df['Rainfall'].fillna(df['Rainfall'].median())

# Fill with the median for humidity-related columns
df['Humidity9am'] = df['Humidity9am'].fillna(df['Humidity9am'].median())
df['Humidity3pm'] = df['Humidity3pm'].fillna(df['Humidity3pm'].median())

# Fill with the mean for wind speed columns
df['WindGustSpeed'] = df['WindGustSpeed'].fillna(df['WindGustSpeed'].mean())
df['WindSpeed9am'] = df['WindSpeed9am'].fillna(df['WindSpeed9am'].mean())
df['WindSpeed3pm'] = df['WindSpeed3pm'].fillna(df['WindSpeed3pm'].mean())

# Fill with median for pressure columns
df['Pressure9am'] = df['Pressure9am'].fillna(df['Pressure9am'].median())
df['Pressure3pm'] = df['Pressure3pm'].fillna(df['Pressure3pm'].median())

# Fill with the mean for evaporation, sunshine, and cloud-related columns
df['Evaporation'] = df['Evaporation'].fillna(df['Evaporation'].mean())
df['Sunshine'] = df['Sunshine'].fillna(df['Sunshine'].mean())
df['Cloud9am'] = df['Cloud9am'].fillna(df['Cloud9am'].mean())
df['Cloud3pm'] = df['Cloud3pm'].fillna(df['Cloud3pm'].mean())

# Fill with mode for wind direction columns
df['WindGustDir'] = df['WindGustDir'].fillna(df['WindGustDir'].mode()[0])
df['WindDir9am'] = df['WindDir9am'].fillna(df['WindDir9am'].mode()[0])
df['WindDir3pm'] = df['WindDir3pm'].fillna(df['WindDir3pm'].mode()[0])

# Fill with mode for RainToday and RainTomorrow
df['RainToday'] = df['RainToday'].fillna(df['RainToday'].mode()[0])
df['RainTomorrow'] = df['RainTomorrow'].fillna(df['RainTomorrow'].mode()[0])


df.head()



# @title Encode all object column
label_encoder = LabelEncoder()
for column in df.columns:
    if df[column].dtype == 'object':
        df[column] = label_encoder.fit_transform(df[column])



#COpy my dataset to final_data
final_data = df.copy()
final_data.head()



correlation = final_data.corr()
target_corr = correlation['RainTomorrow'].sort_values(ascending=False)
target_corr = target_corr.drop('RainTomorrow')




# Assuming `target_corr` is a pandas Series of correlation values
mini = np.min(target_corr)
maxi = np.max(target_corr)
print("Minimum correlation value:", mini)
print("Maximum correlation value:", maxi)




# Assuming `final_data` is your DataFrame
# Calculate the correlation matrix
correlation = final_data.corr()
# Extract the correlations with 'RainTomorrow'
target_corr = correlation['RainTomorrow'].sort_values(ascending=False)
# Define thresholds for high and medium correlation
high_threshold = 0.25
medium_threshold = 0.10

# Select features with correlation higher than the high threshold or the medium threshold
selected_features = target_corr[(target_corr > high_threshold) |
                                (target_corr > medium_threshold)].index.tolist()

# Optionally, remove 'RainTomorrow' from the list if it is present
if 'RainTomorrow' in selected_features:
    selected_features.remove('RainTomorrow')

print("Selected features with high and medium correlation:")
print(selected_features)
# Create a new dataset with these features
new_data = final_data[selected_features + ['RainTomorrow']]




new_data.shape





new_data.head(20)





# @title Logistic Regression

# Prepare the feature matrix `X` and target variable `y`
X = new_data[selected_features]
y = new_data['RainTomorrow']

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and train the Logistic Regression model
log_reg = LogisticRegression(random_state=42)
log_reg.fit(X_train, y_train)

# Make predictions
y_pred = log_reg.predict(X_test)
accuracy = accuracy_score(y_pred, y_test)
print('Accuracy is: ', accuracy*100)





#@title Pickle File
with open('Classifier.pkl', 'wb') as file:
  pickle.dump(log_reg, file)



